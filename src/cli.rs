use clap::{App, SubCommand, Arg};

pub fn generate_cli() -> App<'static, 'static> {
    App::new("Tools for Allwinner devices in FEL mode")
        .version(crate_version!())
        .author("Iban Eguia (Razican) <razican@protonmail.ch>")
        .about("Flashes bootloaders to Allwinner ARM devices")
        .arg(Arg::with_name("device")
            .help("The USB bus and device address of the FEL device")
            .short("d")
            .long("device")
            .value_name("bus:addr")
            .takes_value(true))
        .subcommand(SubCommand::with_name("spl")
            .about("Loads and executes U-Boot SPL. If file additionally contains a main U-Boot \
                    binary, it will transfer it to memory and print the entry point address, in \
                    hex")
            .arg(Arg::with_name("file")
                .help("The binary file with the SPL")
                .takes_value(true)
                .required(true))
            .arg(Arg::with_name("exec")
                .help("Execute U-Boot binary instead of printing the entry point address")
                .short("x")
                .long("exec")))
        .subcommand(SubCommand::with_name("dump")
            .about("Dumps memory region in binary through stdout")
            .arg(Arg::with_name("addr")
                .help("The memory address to dump")
                .takes_value(true)
                .required_unless("sid")
                .conflicts_with("sid"))
            .arg(Arg::with_name("size")
                .help("The size of the dumped memory chunk, in bytes. By default, a 32-bit word \
                       (4 bytes)")
                .takes_value(true)
                .conflicts_with("sid"))
            .arg(Arg::with_name("hex")
                .help("Dump memory in hexadecimal instead of binary")
                .long("hex")
                .conflicts_with_all(&["out", "sid"]))
            .arg(Arg::with_name("sid")
                .help("Get the value of the SID registers")
                .long("sid")
                .conflicts_with_all(&["addr", "size", "hex", "out"]))
            .arg(Arg::with_name("out")
                .help("Output binary data to the specified file. Note: it will be overwriten if \
                       it already exists")
                .short("o")
                .long("out")
                .conflicts_with_all(&["hex", "sid"])
                .takes_value(true)))
        .subcommand(SubCommand::with_name("write")
            .about("Write data to device memory")
            .arg(Arg::with_name("write_data")
                .help("Address to start writing and 32-bit word or input file to write")
                .takes_value(true)
                .required(true)
                .multiple(true)
                .value_names(&["address", "word|file"])))
        .subcommand(SubCommand::with_name("exec")
            .about("Call function at the given address")
            .arg(Arg::with_name("addr")
                .help("Memory address to call")
                .takes_value(true)
                .required(true)))
        .subcommand(SubCommand::with_name("reset64")
            .about("RMR request for AArch64 warm boot")
            .arg(Arg::with_name("addr").takes_value(true).required(true)))
        .subcommand(SubCommand::with_name("version").about("Gets SoC version information"))
        .subcommand(SubCommand::with_name("clear")
            .about("Clear memory")
            .arg(Arg::with_name("addr")
                .help("Memory address to clear (set to 0x00)")
                .takes_value(true)
                .required(true))
            .arg(Arg::with_name("num_bytes")
                .help("Number of bytes to clear. By default, a 32-bit word (4 bytes)")
                .takes_value(true)
                .default_value("4")))
        .subcommand(SubCommand::with_name("fill")
            .about("Fill memory with the given byte")
            .arg(Arg::with_name("addr")
                .help("Memory address to fill")
                .takes_value(true)
                .required(true))
            .arg(Arg::with_name("num_bytes")
                .help("Number of bytes to fill. By default, a 32-bit word (4 bytes)")
                .takes_value(true)
                .default_value("4"))
            .arg(Arg::with_name("fill_byte")
                .help("Byte to use to fill the memory")
                .takes_value(true)
                .required(true)))
}
